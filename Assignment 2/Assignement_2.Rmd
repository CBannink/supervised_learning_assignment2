---
title: "Assignment 2"
author: "Iris van Engen, Sara Claus, Caspar Bannink, Wessel Brouwer"
output: html_document
date: "2023-10-25"
editor_options: 
  markdown: 
    wrap: 72
---

Libraries:

```{r}
library(ggplot2)
library(tidyverse) 
library(viridis)
library(ggpubr)
library(rpart)
library(psych)
library(rpart.plot)
library(randomForest)
library(magrittr)
library(caret)
```

# Introducing the dataset

To do:\
- choose a dataset\
- clean dataset - explain dataset - introduce what question we want to
answer (so what is the dependent variable and are the independent
variables)

# Representing the data

Content: make few interesting plots

# Simple model

To do: - Make a simple model - Explain model method (linear
regression?) - Create confusion matrix - Explain de predictions (which
are the truly true, falsly true etc) - Evaluate the performance of the
model

# Importing dataset

```{r}
# Importing datasets 
red_wine <- read.csv("wine+quality/winequality-red.csv", sep = ";")
white_wine <- read.csv("wine+quality/winequality-white.csv", sep = ";")
white_wine %>%  mutate(quality = as.factor(quality))
```

```{r}
summary(white_wine)
```

# Introducing dataset

This dataset from Cortez et al.,2009 contains information of 4898 types
of white wine. For each wine, 12 measurements have been gathered and
collected in this dataset. The dataset contains the following
variables. - Fixed acidity, grams of tartaric acids per liter - Volatile
acidity, grams of acetic acid per liter - citric acid, in gram per
liter - residual sugar, the amount of leftover sugar in the wine bottle
in gram per liter - chlorides, grams of sodium chloride per liter - free
sulfur dioxides, in milligram per liter - total sulfur dioxides, in
milligram per liter - density, is the grams per mililiter - pH, measure
for the acidity of a wine. A pH below 7 meaning that it is considered
acidic, a pH above 7 is considered basic. - sulphates, grams of
potassium sulphate per liter - alcohol, percentage of alcohol of total
wine volume. - quality, a number from 1 to 10 to rate the taste of wine
based on triplicate blinde taste test.

We want to be able to predict based on above described physiochemical
properties whether a wine will be of good quality or not. To get an idea
of the differences in physiochemical properties between different
quality-ratings, we summarized the medians of all variables grouped by
quality.

```{r}
white_wine %>% 
  group_by(quality) %>% 
  summarise(n_observations = length(quality),
            median_alcohol = median(alcohol),
            median_chorides = median(chlorides),
            median_density = median(density), 
            median_pH = median(pH),
            median_sulphates = median(sulphates), 
            median_fixed_acidity = median(fixed.acidity),
            median_volatile_acidity = median(volatile.acidity),
            median_total.sulfur.dioxide = median(total.sulfur.dioxide),
            median_free.sulfur.dioxide = median(free.sulfur.dioxide),
            median_citric.acid = median(citric.acid),
            median_residual.sugar = median(residual.sugar))
```

The majority of wines are scored within 5-7 range. Only very few wines
could be considered bad (3-4) and only few wines could be considered
good (8-9) wines.

```{r}
white_wine %>% 
  ggplot(aes(x = quality))+ 
  geom_bar()+
  labs(xlab = "quality",
       ylab = "count",
       title = "wine quality")+
  theme_minimal()
  
```

Based on the table with median values grouped by quality score, we do
not have a clear idea of what influences the quality of white wines. To
get a better idea, we plotted quality score grouped boxplots for all
variables.

```{r}
make_box <- function(y_data, y_labs){
  white_wine %>% ggplot(aes(y = y_data)) + 
    geom_boxplot(fill = "sea green") +
    facet_wrap(~quality, ncol = 7) +
    ylab(y_labs) +
    theme(axis.text.x = element_blank())
}

box_alc <- make_box(white_wine$alcohol, "Alcohol %")
box_chl <- make_box(white_wine$chlorides, "Ahlorides")
box_free_so2 <- make_box(white_wine$free.sulfur.dioxide, "Free sulfur dioxide")
box_tot_so2 <- make_box(white_wine$total.sulfur.dioxide, "Total sulfur dioxide")
box_fix_acid <- make_box(white_wine$fixed.acidity, "Fixed acidity")
box_vol_acid <- make_box(white_wine$volatile.acidity, "volatile acidity")
box_cit_acid <- make_box(white_wine$citric.acid, "Citric acid")
box_res_sug <- make_box(white_wine$residual.sugar, "Residual sugar")
box_pH <- make_box(white_wine$pH, "pH")
box_dens <- make_box(white_wine$density, "Density")
box_sulp <- make_box(white_wine$sulphates, "Sulphates")

fig2 <- ggarrange(box_cit_acid,box_vol_acid,box_fix_acid,box_tot_so2,box_free_so2, labels = c("F","G","H","I","J","K"), ncol = 3, nrow = 2)
fig1 <- ggarrange(box_alc,box_dens, box_pH, box_chl,box_res_sug, box_sulp,labels = c("A","B","C","D","E"), ncol = 3, nrow = 2)

annotate_figure(fig1, top = text_grob("Boxplots of physiochemical properties of wine",color = "black", face = "bold", size = 14),
                fig.lab = "Figure 1", fig.lab.face = "bold")

annotate_figure(fig2, top = text_grob("Boxplots of physiochemical properties of wine",color = "black", face = "bold", size = 14),
                fig.lab = "Figure 2", fig.lab.face = "bold")

```

The boxplots show, that apart from alcohol percentage, there is not much
difference going up or down single quality scores. Estimating quality
accurate would be hard and unnecessary. Therefore, we will make a model
that is able to classify bad, neutral and good from eachother.

```{r}
white_wine_duplicated <- white_wine %>% 
  mutate(group = ifelse(quality < 6, "Bad", "Good"))
white_wine <- white_wine %>%
  mutate(group = ifelse(quality < 7, "Bad", "Good"))

make_box_1 <- function(y_data, y_labs){
  white_wine %>% ggplot(aes(y = y_data)) + 
    geom_boxplot(fill = "sea green") +
    facet_wrap(~group) +
    ylab(y_labs) +
    theme(axis.text.x = element_blank())
}


box_alc_1 <- make_box_1(white_wine$alcohol, "alcohol %")
box_chl_1 <- make_box_1(white_wine$chlorides, "chlorides")
box_free_so2_1 <- make_box_1(white_wine$free.sulfur.dioxide, "Free sulfur dioxide")
box_tot_so2_1 <- make_box_1(white_wine$total.sulfur.dioxide, "Total sulfur dioxide")
box_fix_acid_1 <- make_box_1(white_wine$fixed.acidity, "Fixed acidity")
box_vol_acid_1 <- make_box_1(white_wine$volatile.acidity, "volatile acidity")
box_cit_acid_1 <- make_box_1(white_wine$citric.acid, "Citric acid")
box_res_sug_1 <- make_box_1(white_wine$residual.sugar, "Residual sugar")
box_pH_1 <- make_box_1(white_wine$pH, "pH")
box_dens_1 <- make_box_1(white_wine$density, "Density")
box_sulp_1 <- make_box_1(white_wine$sulphates, "Sulphates")



fig2 <- ggarrange(box_cit_acid_1,box_vol_acid_1,box_fix_acid_1,box_tot_so2_1,box_free_so2_1, labels = c("F","G","H","I","J","K"), ncol = 3, nrow = 2)
fig1 <- ggarrange(box_alc_1,box_dens_1, box_pH_1, box_chl_1,box_res_sug_1, box_sulp_1,labels = c("A","B","C","D","E"), ncol = 3, nrow = 2)

annotate_figure(fig1, top = text_grob("Boxplots of physiochemical properties of wine",color = "black", face = "bold", size = 14),
                fig.lab = "Figure 1", fig.lab.face = "bold")

annotate_figure(fig2, top = text_grob("Boxplots of physiochemical properties of wine",color = "black", face = "bold", size = 14),
                fig.lab = "Figure 1", fig.lab.face = "bold")

```

Since it is not possible to pinpoint a single feature that highly
influences the quality of white wine based on visualization, we want to
check whether their are strong correlations between our groups.

```{r}
cor(white_wine[,c(1:12)])

```

```{r}
white_wine %>% 
  ggplot(aes(x = volatile.acidity, y = fixed.acidity, color = quality))+ 
  geom_point()+
  scale_color_viridis()+
  labs(xlab = "volatile acidity",
       ylab = "fixed acidity",
       title = "Effect of acidity on quality")+
  theme_minimal()+ 
  facet_wrap(.~ group)

```

```{r}
white_wine %>% 
  ggplot(aes(x = pH, y = citric.acid, color = quality))+ 
  geom_point()+
  scale_color_viridis()+
  labs(xlab = "volatile acidity",
       ylab = "fixed acidity",
       title = "Effect of acidity on quality")+
  theme_minimal()+ 
  facet_wrap(.~ group)
```

```{r}
white_wine %>% 
  ggplot(aes(x = density, y = alcohol, color = quality))+ 
  geom_point(aes(alpha = 0.8))+
  scale_color_viridis()+
  labs(xlab = "density",
       ylab = "chlorides",
       title = "Effect of acidity on quality")+
  theme_minimal()+ 
  facet_wrap(.~ group)
```

```{r}
set.seed(123)
white_wine <- white_wine %>% 
  select(!(quality)) 
white_wine <- white_wine %>% 
  mutate(split = sample(c(rep("Test",490), rep("Train", 4408))))


bad_indices <- which(white_wine_duplicated$group == "Bad")

# Duplicate the "Bad" class instances
duplicated_data <- white_wine_duplicated[bad_indices, ]

# Combine the duplicated instances with the original dataset
balanced_data <- rbind(white_wine_duplicated, duplicated_data)
white_wine_duplicated = balanced_data
white_wine_duplicated <- white_wine_duplicated %>% 
  select(!(quality)) 
white_wine_duplicated <- white_wine_duplicated %>% 
  mutate(split = sample(c(rep("Test",653), rep("Train", 5885))))


wwTrain <- white_wine %>% filter(split =="Train")
wwTest <- white_wine %>% filter(split =="Test")
wwTrain_duplicated <- white_wine_duplicated %>% filter(split =="Train")
wwTest_duplicated <- white_wine_duplicated %>% filter(split =="Test")
wwTrain = subset(wwTrain, select = -split)
wwTest = subset(wwTest,select=-split)
wwTrain_duplicated = subset(wwTrain_duplicated, select = -split)
wwTest_duplicated = subset(wwTest_duplicated,select= -split)


ncol_train = ncol(wwTrain)
ncol_train_duplicated = ncol(wwTrain_duplicated)

grid = expand.grid(mtry = c(ncol_train-1, sqrt(ncol_train), ncol_train/2))
model <- train(group ~ ., data = wwTrain, method = "rf", trControl = trainControl(method = "repeatedcv", number=10, repeats = 3), tuneGrid =grid, metric="Accuracy")

model_duplicated <- train(group ~ ., data = wwTrain_duplicated, method = "rf", trControl = trainControl(method = "repeatedcv", number=10, repeats = 3), tuneGrid =grid, metric="Accuracy")

best_model <- model$finalModel
best_model_duplicated = model_duplicated$finalModel

predictions <- predict(best_model, wwTest)
predictions_duplicated = predict(best_model_duplicated, wwTest_duplicated)

accuracy <- mean(wwTest$group == predictions)
accuracy_duplicated = mean(wwTest_duplicated$group == predictions_duplicated)
accuracy
accuracy_duplicated


grid_simple = expand.grid(cp = c(0.01, 0.001, 1, 0.1))
model_simple <- train(group ~ ., data = wwTrain, method = "rpart", trControl = trainControl(method = "repeatedcv",number = 10, repeats = 3,classProbs = FALSE), metric="Accuracy", tuneGrid = grid_simple)
model_simple_duplicated <- train(group ~ ., data = wwTrain_duplicated, method = "rpart", trControl = trainControl(method = "repeatedcv",number = 10, repeats = 3,classProbs = FALSE), metric="Accuracy", tuneGrid = grid_simple)

best_model_simple <- model_simple$finalModel
best_model_simple_duplicated = model_simple_duplicated$finalModel

predictions_simple <- predict(best_model_simple, wwTest)
predictions_simple = data.frame(predictions_simple)
result_df <- data.frame(matrix(ncol = 1, nrow = nrow(predictions_simple)))
result_df$predicted_class <- ifelse(predictions_simple$Good >= 0.5, "Good", "Bad")# Assign classes based on the 

predictions_simple_duplicated <- predict(best_model_simple_duplicated, wwTest_duplicated)
predictions_simple_duplicated = data.frame(predictions_simple_duplicated)
result_df_duplicated <- data.frame(matrix(ncol = 1, nrow = nrow(predictions_simple_duplicated)))
result_df_duplicated$predicted_class <- ifelse(predictions_simple_duplicated$Good >= 0.5, "Good", "Bad")# Assign classes based on the


accuracy_simple <- mean(wwTest$group == result_df$predicted_class)
accuracy_simple_duplicated = mean(wwTest_duplicated$group ==result_df_duplicated$predicted_class )
accuracy_simple
accuracy_simple_duplicated
best_model_simple
best_model

```
